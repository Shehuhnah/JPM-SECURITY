{
  "version": 3,
  "sources": ["../../@eslint/config-helpers/dist/cjs/index.cjs", "../../eslint/lib/config-api.js"],
  "sourcesContent": ["'use strict';\r\n\r\n/**\r\n * @fileoverview defineConfig helper\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Type Definitions\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @typedef {import(\"eslint\").Linter.Config} Config */\r\n/** @typedef {import(\"eslint\").Linter.LegacyConfig} LegacyConfig */\r\n/** @typedef {import(\"eslint\").ESLint.Plugin} Plugin */\r\n/** @typedef {import(\"eslint\").Linter.RuleEntry} RuleEntry */\r\n/** @typedef {import(\"./types.ts\").ExtendsElement} ExtendsElement */\r\n/** @typedef {import(\"./types.ts\").SimpleExtendsElement} SimpleExtendsElement */\r\n/** @typedef {import(\"./types.ts\").ConfigWithExtends} ConfigWithExtends */\r\n/** @typedef {import(\"./types.ts\").InfiniteArray<Config>} InfiniteConfigArray */\r\n/** @typedef {import(\"./types.ts\").ConfigWithExtendsArray} ConfigWithExtendsArray */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nconst eslintrcKeys = [\r\n\t\"env\",\r\n\t\"extends\",\r\n\t\"globals\",\r\n\t\"ignorePatterns\",\r\n\t\"noInlineConfig\",\r\n\t\"overrides\",\r\n\t\"parser\",\r\n\t\"parserOptions\",\r\n\t\"reportUnusedDisableDirectives\",\r\n\t\"root\",\r\n];\r\n\r\nconst allowedGlobalIgnoreKeys = new Set([\"basePath\", \"ignores\", \"name\"]);\r\n\r\n/**\r\n * Gets the name of a config object.\r\n * @param {Config} config The config object.\r\n * @param {string} indexPath The index path of the config object.\r\n * @return {string} The name of the config object.\r\n */\r\nfunction getConfigName(config, indexPath) {\r\n\tif (config.name) {\r\n\t\treturn config.name;\r\n\t}\r\n\r\n\treturn `UserConfig${indexPath}`;\r\n}\r\n\r\n/**\r\n * Gets the name of an extension.\r\n * @param {SimpleExtendsElement} extension The extension.\r\n * @param {string} indexPath The index of the extension.\r\n * @return {string} The name of the extension.\r\n */\r\nfunction getExtensionName(extension, indexPath) {\r\n\tif (typeof extension === \"string\") {\r\n\t\treturn extension;\r\n\t}\r\n\r\n\tif (extension.name) {\r\n\t\treturn extension.name;\r\n\t}\r\n\r\n\treturn `ExtendedConfig${indexPath}`;\r\n}\r\n\r\n/**\r\n * Determines if a config object is a legacy config.\r\n * @param {Config|LegacyConfig} config The config object to check.\r\n * @return {config is LegacyConfig} `true` if the config object is a legacy config.\r\n */\r\nfunction isLegacyConfig(config) {\r\n\tfor (const key of eslintrcKeys) {\r\n\t\tif (key in config) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n/**\r\n * Determines if a config object is a global ignores config.\r\n * @param {Config} config The config object to check.\r\n * @return {boolean} `true` if the config object is a global ignores config.\r\n */\r\nfunction isGlobalIgnores(config) {\r\n\treturn Object.keys(config).every(key => allowedGlobalIgnoreKeys.has(key));\r\n}\r\n\r\n/**\r\n * Parses a plugin member ID (rule, processor, etc.) and returns\r\n * the namespace and member name.\r\n * @param {string} id The ID to parse.\r\n * @returns {{namespace:string, name:string}} The namespace and member name.\r\n */\r\nfunction getPluginMember(id) {\r\n\tconst firstSlashIndex = id.indexOf(\"/\");\r\n\r\n\tif (firstSlashIndex === -1) {\r\n\t\treturn { namespace: \"\", name: id };\r\n\t}\r\n\r\n\tlet namespace = id.slice(0, firstSlashIndex);\r\n\r\n\t/*\r\n\t * Special cases:\r\n\t * 1. The namespace is `@`, that means it's referring to the\r\n\t *    core plugin so `@` is the full namespace.\r\n\t * 2. The namespace starts with `@`, that means it's referring to\r\n\t *    an npm scoped package. That means the namespace is the scope\r\n\t *    and the package name (i.e., `@eslint/core`).\r\n\t */\r\n\tif (namespace[0] === \"@\" && namespace !== \"@\") {\r\n\t\tconst secondSlashIndex = id.indexOf(\"/\", firstSlashIndex + 1);\r\n\t\tif (secondSlashIndex !== -1) {\r\n\t\t\tnamespace = id.slice(0, secondSlashIndex);\r\n\t\t\treturn { namespace, name: id.slice(secondSlashIndex + 1) };\r\n\t\t}\r\n\t}\r\n\r\n\tconst name = id.slice(firstSlashIndex + 1);\r\n\r\n\treturn { namespace, name };\r\n}\r\n\r\n/**\r\n * Normalizes the plugin config by replacing the namespace with the plugin namespace.\r\n * @param {string} userNamespace The namespace of the plugin.\r\n * @param {Plugin} plugin The plugin config object.\r\n * @param {Config} config The config object to normalize.\r\n * @return {Config} The normalized config object.\r\n */\r\nfunction normalizePluginConfig(userNamespace, plugin, config) {\r\n\tconst pluginNamespace = plugin.meta?.namespace;\r\n\r\n\t// don't do anything if the plugin doesn't have a namespace or rules\r\n\tif (\r\n\t\t!pluginNamespace ||\r\n\t\tpluginNamespace === userNamespace ||\r\n\t\t(!config.rules && !config.processor && !config.language)\r\n\t) {\r\n\t\treturn config;\r\n\t}\r\n\r\n\tconst result = { ...config };\r\n\r\n\t// update the rules\r\n\tif (result.rules) {\r\n\t\tconst ruleIds = Object.keys(result.rules);\r\n\r\n\t\t/** @type {Record<string,RuleEntry|undefined>} */\r\n\t\tconst newRules = {};\r\n\r\n\t\tfor (let i = 0; i < ruleIds.length; i++) {\r\n\t\t\tconst ruleId = ruleIds[i];\r\n\t\t\tconst { namespace: ruleNamespace, name: ruleName } =\r\n\t\t\t\tgetPluginMember(ruleId);\r\n\r\n\t\t\tif (ruleNamespace === pluginNamespace) {\r\n\t\t\t\tnewRules[`${userNamespace}/${ruleName}`] = result.rules[ruleId];\r\n\t\t\t} else {\r\n\t\t\t\tnewRules[ruleId] = result.rules[ruleId];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.rules = newRules;\r\n\t}\r\n\r\n\t// update the processor\r\n\r\n\tif (typeof result.processor === \"string\") {\r\n\t\tconst { namespace: processorNamespace, name: processorName } =\r\n\t\t\tgetPluginMember(result.processor);\r\n\r\n\t\tif (processorNamespace) {\r\n\t\t\tif (processorNamespace === pluginNamespace) {\r\n\t\t\t\tresult.processor = `${userNamespace}/${processorName}`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// update the language\r\n\tif (typeof result.language === \"string\") {\r\n\t\tconst { namespace: languageNamespace, name: languageName } =\r\n\t\t\tgetPluginMember(result.language);\r\n\r\n\t\tif (languageNamespace === pluginNamespace) {\r\n\t\t\tresult.language = `${userNamespace}/${languageName}`;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Deeply normalizes a plugin config, traversing recursively into an arrays.\r\n * @param {string} userPluginNamespace The namespace of the plugin.\r\n * @param {Plugin} plugin The plugin object.\r\n * @param {Config|LegacyConfig|(Config|LegacyConfig)[]} pluginConfig The plugin config to normalize.\r\n * @param {string} pluginConfigName The name of the plugin config.\r\n * @return {InfiniteConfigArray} The normalized plugin config.\r\n * @throws {TypeError} If the plugin config is a legacy config.\r\n */\r\nfunction deepNormalizePluginConfig(\r\n\tuserPluginNamespace,\r\n\tplugin,\r\n\tpluginConfig,\r\n\tpluginConfigName,\r\n) {\r\n\t// if it's an array then it's definitely a new config\r\n\tif (Array.isArray(pluginConfig)) {\r\n\t\treturn pluginConfig.map(pluginSubConfig =>\r\n\t\t\tdeepNormalizePluginConfig(\r\n\t\t\t\tuserPluginNamespace,\r\n\t\t\t\tplugin,\r\n\t\t\t\tpluginSubConfig,\r\n\t\t\t\tpluginConfigName,\r\n\t\t\t),\r\n\t\t);\r\n\t}\r\n\r\n\t// if it's a legacy config, throw an error\r\n\tif (isLegacyConfig(pluginConfig)) {\r\n\t\tthrow new TypeError(\r\n\t\t\t`Plugin config \"${pluginConfigName}\" is an eslintrc config and cannot be used in this context.`,\r\n\t\t);\r\n\t}\r\n\r\n\treturn normalizePluginConfig(userPluginNamespace, plugin, pluginConfig);\r\n}\r\n\r\n/**\r\n * Finds a plugin config by name in the given config.\r\n * @param {Config} config The config object.\r\n * @param {string} pluginConfigName The name of the plugin config.\r\n * @return {InfiniteConfigArray} The plugin config.\r\n * @throws {TypeError} If the plugin config is not found or is a legacy config.\r\n */\r\nfunction findPluginConfig(config, pluginConfigName) {\r\n\tconst { namespace: userPluginNamespace, name: configName } =\r\n\t\tgetPluginMember(pluginConfigName);\r\n\tconst plugin = config.plugins?.[userPluginNamespace];\r\n\r\n\tif (!plugin) {\r\n\t\tthrow new TypeError(`Plugin \"${userPluginNamespace}\" not found.`);\r\n\t}\r\n\r\n\tconst directConfig = plugin.configs?.[configName];\r\n\tif (directConfig) {\r\n\t\t// Arrays are always flat configs, and non-legacy configs can be used directly\r\n\t\tif (Array.isArray(directConfig) || !isLegacyConfig(directConfig)) {\r\n\t\t\treturn deepNormalizePluginConfig(\r\n\t\t\t\tuserPluginNamespace,\r\n\t\t\t\tplugin,\r\n\t\t\t\tdirectConfig,\r\n\t\t\t\tpluginConfigName,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// If it's a legacy config, look for the flat version\r\n\t\tconst flatConfig = plugin.configs?.[`flat/${configName}`];\r\n\r\n\t\tif (\r\n\t\t\tflatConfig &&\r\n\t\t\t(Array.isArray(flatConfig) || !isLegacyConfig(flatConfig))\r\n\t\t) {\r\n\t\t\treturn deepNormalizePluginConfig(\r\n\t\t\t\tuserPluginNamespace,\r\n\t\t\t\tplugin,\r\n\t\t\t\tflatConfig,\r\n\t\t\t\tpluginConfigName,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthrow new TypeError(\r\n\t\t\t`Plugin config \"${configName}\" in plugin \"${userPluginNamespace}\" is an eslintrc config and cannot be used in this context.`,\r\n\t\t);\r\n\t}\r\n\r\n\tthrow new TypeError(\r\n\t\t`Plugin config \"${configName}\" not found in plugin \"${userPluginNamespace}\".`,\r\n\t);\r\n}\r\n\r\n/**\r\n * Flattens an array while keeping track of the index path.\r\n * @param {any[]} configList The array to traverse.\r\n * @param {string} indexPath The index path of the value in a multidimensional array.\r\n * @return {IterableIterator<{indexPath:string, value:any}>} The flattened list of values.\r\n */\r\nfunction* flatTraverse(configList, indexPath = \"\") {\r\n\tfor (let i = 0; i < configList.length; i++) {\r\n\t\tconst newIndexPath = indexPath ? `${indexPath}[${i}]` : `[${i}]`;\r\n\r\n\t\t// if it's an array then traverse it as well\r\n\t\tif (Array.isArray(configList[i])) {\r\n\t\t\tyield* flatTraverse(configList[i], newIndexPath);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tyield { indexPath: newIndexPath, value: configList[i] };\r\n\t}\r\n}\r\n\r\n/**\r\n * Extends a list of config files by creating every combination of base and extension files.\r\n * @param {(string|string[])[]} [baseFiles] The base files.\r\n * @param {(string|string[])[]} [extensionFiles] The extension files.\r\n * @return {(string|string[])[]} The extended files.\r\n */\r\nfunction extendConfigFiles(baseFiles = [], extensionFiles = []) {\r\n\tif (!extensionFiles.length) {\r\n\t\treturn baseFiles.concat();\r\n\t}\r\n\r\n\tif (!baseFiles.length) {\r\n\t\treturn extensionFiles.concat();\r\n\t}\r\n\r\n\t/** @type {(string|string[])[]} */\r\n\tconst result = [];\r\n\r\n\tfor (const baseFile of baseFiles) {\r\n\t\tfor (const extensionFile of extensionFiles) {\r\n\t\t\t/*\r\n\t\t\t * Each entry can be a string or array of strings. The end result\r\n\t\t\t * needs to be an array of strings, so we need to be sure to include\r\n\t\t\t * all of the items when there's an array.\r\n\t\t\t */\r\n\r\n\t\t\tconst entry = [];\r\n\r\n\t\t\tif (Array.isArray(baseFile)) {\r\n\t\t\t\tentry.push(...baseFile);\r\n\t\t\t} else {\r\n\t\t\t\tentry.push(baseFile);\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(extensionFile)) {\r\n\t\t\t\tentry.push(...extensionFile);\r\n\t\t\t} else {\r\n\t\t\t\tentry.push(extensionFile);\r\n\t\t\t}\r\n\r\n\t\t\tresult.push(entry);\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Extends a config object with another config object.\r\n * @param {Config} baseConfig The base config object.\r\n * @param {string} baseConfigName The name of the base config object.\r\n * @param {Config} extension The extension config object.\r\n * @param {string} extensionName The index of the extension config object.\r\n * @return {Config} The extended config object.\r\n */\r\nfunction extendConfig(baseConfig, baseConfigName, extension, extensionName) {\r\n\tconst result = { ...extension };\r\n\r\n\t// for global ignores there is no further work to be done, we just keep everything\r\n\tif (!isGlobalIgnores(extension)) {\r\n\t\t// for files we need to create every combination of base and extension files\r\n\t\tif (baseConfig.files) {\r\n\t\t\tresult.files = extendConfigFiles(baseConfig.files, extension.files);\r\n\t\t}\r\n\r\n\t\t// for ignores we just concatenation the extension ignores onto the base ignores\r\n\t\tif (baseConfig.ignores) {\r\n\t\t\tresult.ignores = baseConfig.ignores.concat(extension.ignores ?? []);\r\n\t\t}\r\n\t}\r\n\r\n\tresult.name = `${baseConfigName} > ${extensionName}`;\r\n\r\n\t// @ts-ignore -- ESLint types aren't updated yet\r\n\tif (baseConfig.basePath) {\r\n\t\t// @ts-ignore -- ESLint types aren't updated yet\r\n\t\tresult.basePath = baseConfig.basePath;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Processes a list of extends elements.\r\n * @param {ConfigWithExtends} config The config object.\r\n * @param {WeakMap<Config, string>} configNames The map of config objects to their names.\r\n * @return {Config[]} The flattened list of config objects.\r\n * @throws {TypeError} If the `extends` property is not an array or if nested `extends` is found.\r\n */\r\nfunction processExtends(config, configNames) {\r\n\tif (!config.extends) {\r\n\t\treturn [config];\r\n\t}\r\n\r\n\tif (!Array.isArray(config.extends)) {\r\n\t\tthrow new TypeError(\"The `extends` property must be an array.\");\r\n\t}\r\n\r\n\tconst {\r\n\t\t/** @type {Config[]} */\r\n\t\textends: extendsList,\r\n\r\n\t\t/** @type {Config} */\r\n\t\t...configObject\r\n\t} = config;\r\n\r\n\tconst extensionNames = new WeakMap();\r\n\r\n\t// replace strings with the actual configs\r\n\tconst objectExtends = extendsList.map(extendsElement => {\r\n\t\tif (typeof extendsElement === \"string\") {\r\n\t\t\tconst pluginConfig = findPluginConfig(config, extendsElement);\r\n\r\n\t\t\t// assign names\r\n\t\t\tif (Array.isArray(pluginConfig)) {\r\n\t\t\t\tpluginConfig.forEach((pluginConfigElement, index) => {\r\n\t\t\t\t\textensionNames.set(\r\n\t\t\t\t\t\tpluginConfigElement,\r\n\t\t\t\t\t\t`${extendsElement}[${index}]`,\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\textensionNames.set(pluginConfig, extendsElement);\r\n\t\t\t}\r\n\r\n\t\t\treturn pluginConfig;\r\n\t\t}\r\n\r\n\t\treturn /** @type {Config} */ (extendsElement);\r\n\t});\r\n\r\n\tconst result = [];\r\n\r\n\tfor (const { indexPath, value: extendsElement } of flatTraverse(\r\n\t\tobjectExtends,\r\n\t)) {\r\n\t\tconst extension = /** @type {Config} */ (extendsElement);\r\n\r\n\t\tif (\"basePath\" in extension) {\r\n\t\t\tthrow new TypeError(\"'basePath' in `extends` is not allowed.\");\r\n\t\t}\r\n\r\n\t\tif (\"extends\" in extension) {\r\n\t\t\tthrow new TypeError(\"Nested 'extends' is not allowed.\");\r\n\t\t}\r\n\r\n\t\tconst baseConfigName = /** @type {string} */ (configNames.get(config));\r\n\t\tconst extensionName =\r\n\t\t\textensionNames.get(extendsElement) ??\r\n\t\t\tgetExtensionName(extendsElement, indexPath);\r\n\r\n\t\tresult.push(\r\n\t\t\textendConfig(\r\n\t\t\t\tconfigObject,\r\n\t\t\t\tbaseConfigName,\r\n\t\t\t\textension,\r\n\t\t\t\textensionName,\r\n\t\t\t),\r\n\t\t);\r\n\t}\r\n\r\n\t/*\r\n\t * If the base config object has only `ignores` and `extends`, then\r\n\t * removing `extends` turns it into a global ignores, which is not what\r\n\t * we want. So we need to check if the base config object is a global ignores\r\n\t * and if so, we don't add it to the array.\r\n\t *\r\n\t * (The other option would be to add a `files` entry, but that would result\r\n\t * in a config that didn't actually do anything because there are no\r\n\t * other keys in the config.)\r\n\t */\r\n\tif (!isGlobalIgnores(configObject)) {\r\n\t\tresult.push(configObject);\r\n\t}\r\n\r\n\treturn result.flat();\r\n}\r\n\r\n/**\r\n * Processes a list of config objects and arrays.\r\n * @param {ConfigWithExtends[]} configList The list of config objects and arrays.\r\n * @param {WeakMap<Config, string>} configNames The map of config objects to their names.\r\n * @return {Config[]} The flattened list of config objects.\r\n */\r\nfunction processConfigList(configList, configNames) {\r\n\treturn configList.flatMap(config => processExtends(config, configNames));\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Helper function to define a config array.\r\n * @param {ConfigWithExtendsArray} args The arguments to the function.\r\n * @returns {Config[]} The config array.\r\n * @throws {TypeError} If no arguments are provided or if an argument is not an object.\r\n */\r\nfunction defineConfig(...args) {\r\n\tconst configNames = new WeakMap();\r\n\tconst configs = [];\r\n\r\n\tif (args.length === 0) {\r\n\t\tthrow new TypeError(\"Expected one or more arguments.\");\r\n\t}\r\n\r\n\t// first flatten the list of configs and get the names\r\n\tfor (const { indexPath, value } of flatTraverse(args)) {\r\n\t\tif (typeof value !== \"object\" || value === null) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t`Expected an object but received ${String(value)}.`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst config = /** @type {ConfigWithExtends} */ (value);\r\n\r\n\t\t// save config name for easy reference later\r\n\t\tconfigNames.set(config, getConfigName(config, indexPath));\r\n\t\tconfigs.push(config);\r\n\t}\r\n\r\n\treturn processConfigList(configs, configNames);\r\n}\r\n\r\n/**\r\n * @fileoverview Global ignores helper function.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Type Definitions\r\n//-----------------------------------------------------------------------------\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nlet globalIgnoreCount = 0;\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Creates a global ignores config with the given patterns.\r\n * @param {string[]} ignorePatterns The ignore patterns.\r\n * @param {string} [name] The name of the global ignores config.\r\n * @returns {Config} The global ignores config.\r\n * @throws {TypeError} If ignorePatterns is not an array or if it is empty.\r\n */\r\nfunction globalIgnores(ignorePatterns, name) {\r\n\tif (!Array.isArray(ignorePatterns)) {\r\n\t\tthrow new TypeError(\"ignorePatterns must be an array\");\r\n\t}\r\n\r\n\tif (ignorePatterns.length === 0) {\r\n\t\tthrow new TypeError(\"ignorePatterns must contain at least one pattern\");\r\n\t}\r\n\r\n\tconst id = globalIgnoreCount++;\r\n\r\n\treturn {\r\n\t\tname: name || `globalIgnores ${id}`,\r\n\t\tignores: ignorePatterns,\r\n\t};\r\n}\r\n\r\nexports.defineConfig = defineConfig;\r\nexports.globalIgnores = globalIgnores;\r\n", "/**\r\n * @fileoverview exports for config helpers\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\nconst { defineConfig, globalIgnores } = require(\"@eslint/config-helpers\");\r\n\r\nmodule.exports = {\r\n\tdefineConfig,\r\n\tglobalIgnores,\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
